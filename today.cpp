#include <iostream>
#include <algrithm> // 알고리즘 헤더
using namespace std;

//아스키코드 출력하는 문제 11564 번 문제

//배열명령어를 쓰지않고 배열정렬하는법
int main()
{

    char n;
    cin >> n;
    cout << (int)n;

    string s = "EACBDF";
    sort(s.begin(), s.end());
    //sort(시작주소 , 마지막주소+1); 마지막주소에 +1은 무엇인곤? 뭐여 이거 원칙이다 마지막주소 + 1을 무조건 넣어준다
    cout << s;

    char ss[] = {'D', 'A', 'F', 'E', 'D'};
    //           s  s+1 s+2 s+3 s+4
    sort(s, s + 5); //여기서 5로 해줘야 한개 뺴고 4개를 0,1,2,3,4 를 전부 배열을 맞춰주는것
    cout << s;

    //정렬해서 출력해서 k에 입력할거야
    char check[26];
    string s = "CADEBF";
    //이 배열을 abcd 순서로 다시 재배열하고 싶어요

    // 배열주소 0 1 2 3 4 5 6 7 8 ..... 24 ; 여기는 영어아스키 코드를 처음부터 잘 배열해 놓은 숫자를 써놓은거
    //  배열값  1  1 1 1 1  1     1     1     1  // 에이 즉 기준이 되는 숫자에서 멀어진 숫자의 인덱스 즉 위치에 1씩 표시해서
    // 여기에 해당하는 알파벳위치를 표시 했기 때문에 배열이 순서가 달라도 앞에서 부터 숫자를 읽으면 배열을 정렬할수 있다
    for (int i = 0; i < s.size(); i++)

    {
        check[s[i] - 'A'] = 1;
        // 차이만큼을 익덱스 배열로 쓴것 알파벳 같은게 잇으면 체크가 있다
        //check[배열의 주소] = 1;  1은 그 배열의 주소에 1을 넣어서 그 알파벳이 잇다고 확인하는거라서 들어가야한다

    } //end for

    //이 아래는 배열 순서대로 다시 읽어와서 배열의 인덱스 숫자를 아스키코드 'A'랑더해서 다시 넣으면
    // 순서대로 되어 있지 않던 배열이 다시 순서대로 배열된다
    for (int i = 0; i < s.size(); i++)
    {
        if (check[i] == 1)
        {
            k += check[i] + 'A'; //여기서 차이난 숫자에 A의 아스키코드 번호만큼 더해서 다시 넣어주면 원래 글자로 변환된다
        }
    }
    cout << k;

    //알파벳의 중복이 있을 경우
    //배열을 정렬하기 위해 입력하는 구분
    for (int i = 0; i < s.size(); i++)
    {
        check[s[i] - 'A']++; //같은 인덱스에 ++ 를 써서 넣어서 그 중복된 알파벳 숫자만큼 넣어주면 몇개 잇는지 확인되고
    }                        //end for

    // 여기서 출력구분
    for (int i = 0; i < s.size(); i++) //위에서 인덱스를 돌려서 찾아가고
    {
        for (int j = 0; j < check[i]; j++) // 값만큼 돌려서 집어넣는것
        {
            k += i + 'A'; //이거는 숫자 확인해서 넣는거고
        }
    }
    cout << k;
}